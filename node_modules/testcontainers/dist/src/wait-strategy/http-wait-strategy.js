"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpWaitStrategy = void 0;
const wait_strategy_1 = require("./wait-strategy");
const retry_strategy_1 = require("../retry-strategy");
const node_fetch_1 = __importDefault(require("node-fetch"));
const https_1 = __importDefault(require("https"));
const docker_client_1 = require("../docker/client/docker-client");
const logger_1 = require("../logger");
class HttpWaitStrategy extends wait_strategy_1.AbstractWaitStrategy {
    constructor(path, port) {
        super();
        this.protocol = "http";
        this.method = "GET";
        this.headers = {};
        this.predicates = [];
        this._allowInsecure = false;
        this.readTimeout = 1000;
        this.path = path;
        this.port = port;
    }
    forStatusCode(statusCode) {
        this.predicates.push((response) => __awaiter(this, void 0, void 0, function* () { return response.status === statusCode; }));
        return this;
    }
    forStatusCodeMatching(predicate) {
        this.predicates.push((response) => __awaiter(this, void 0, void 0, function* () { return predicate(response.status); }));
        return this;
    }
    forResponsePredicate(predicate) {
        this.predicates.push((response) => __awaiter(this, void 0, void 0, function* () { return predicate(yield response.text()); }));
        return this;
    }
    withMethod(method) {
        this.method = method;
        return this;
    }
    withHeaders(headers) {
        this.headers = Object.assign(Object.assign({}, this.headers), headers);
        return this;
    }
    withBasicCredentials(username, password) {
        const base64Encoded = Buffer.from(`${username}:${password}`).toString("base64");
        this.headers = Object.assign(Object.assign({}, this.headers), { Authorization: `Basic ${base64Encoded}` });
        return this;
    }
    withReadTimeout(readTimeout) {
        this.readTimeout = readTimeout;
        return this;
    }
    usingTls() {
        this.protocol = "https";
        return this;
    }
    allowInsecure() {
        this._allowInsecure = true;
        return this;
    }
    waitUntilReady(container, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Waiting for HTTP...`, { containerId: container.id });
            const { host } = yield (0, docker_client_1.getDockerClient)();
            yield new retry_strategy_1.IntervalRetryStrategy(this.readTimeout).retryUntil(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const url = `${this.protocol}://${host}:${boundPorts.getBinding(this.port)}${this.path}`;
                    return yield (0, node_fetch_1.default)(url, {
                        method: this.method,
                        timeout: this.readTimeout,
                        headers: this.headers,
                        agent: this.getAgent(),
                    });
                }
                catch (_a) {
                    return undefined;
                }
            }), (response) => __awaiter(this, void 0, void 0, function* () {
                if (response === undefined) {
                    return false;
                }
                else if (!this.predicates.length) {
                    return response.ok;
                }
                else {
                    for (const predicate of this.predicates) {
                        const result = yield predicate(response);
                        if (!result) {
                            return false;
                        }
                    }
                    return true;
                }
            }), () => {
                const message = `URL ${this.path} not accessible after ${this.startupTimeout}ms`;
                logger_1.log.error(message, { containerId: container.id });
                throw new Error(message);
            }, this.startupTimeout);
        });
    }
    getAgent() {
        if (this._allowInsecure) {
            return new https_1.default.Agent({
                rejectUnauthorized: false,
            });
        }
    }
}
exports.HttpWaitStrategy = HttpWaitStrategy;
