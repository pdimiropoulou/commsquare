import { Clock, Time } from "./clock";
export interface RetryStrategy<T, U> {
    retryUntil(fn: () => Promise<T>, predicate: (result: T) => boolean | Promise<boolean>, onTimeout: () => U, timeout: number): Promise<T | U>;
}
declare abstract class AbstractRetryStrategy<T, U> implements RetryStrategy<T, U> {
    protected readonly clock: Clock;
    protected constructor(clock?: Clock);
    abstract retryUntil(fn: () => Promise<T>, predicate: (result: T) => boolean | Promise<boolean>, onTimeout: () => U, timeout: number): Promise<T | U>;
    protected hasTimedOut(timeout: number, startTime: Time): boolean;
    protected wait(duration: number): Promise<void>;
}
export declare class IntervalRetryStrategy<T, U> extends AbstractRetryStrategy<T, U> {
    private readonly interval;
    constructor(interval: number);
    retryUntil(fn: (attempt: number) => Promise<T>, predicate: (result: T) => boolean | Promise<boolean>, onTimeout: () => U, timeout: number): Promise<T | U>;
}
export {};
