"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReaperInstance = void 0;
const net_1 = require("net");
const logger_1 = require("./logger");
const generic_container_1 = require("./generic-container/generic-container");
const session_id_1 = require("./docker/session-id");
const images_1 = require("./images");
const port_1 = require("./port");
const labels_1 = require("./labels");
const wait_1 = require("./wait-strategy/wait");
const retry_strategy_1 = require("./retry-strategy");
const remote_docker_unix_socket_path_1 = require("./docker/remote-docker-unix-socket-path");
const docker_client_1 = require("./docker/client/docker-client");
class RealReaper {
    constructor(container, socket) {
        this.container = container;
        this.socket = socket;
    }
    addProject(projectName) {
        this.socket.write(`label=com.docker.compose.project=${projectName}\r\n`);
    }
    getContainerId() {
        return this.container.getId();
    }
    stop() {
        this.socket.end();
    }
}
class DisabledReaper {
    addProject() {
        // noop
    }
    stop() {
        // noop
    }
    getContainerId() {
        return "";
    }
}
class ReaperInstance {
    static getInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.instance) {
                if (this.isEnabled()) {
                    this.instance = this.createRealInstance();
                }
                else {
                    this.instance = this.createDisabledInstance();
                }
            }
            return this.instance;
        });
    }
    static stopInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.instance) {
                const reaper = yield this.instance;
                reaper.stop();
                this.instance = undefined;
            }
        });
    }
    static isEnabled() {
        return process.env.TESTCONTAINERS_RYUK_DISABLED !== "true";
    }
    static isPrivileged() {
        return process.env.TESTCONTAINERS_RYUK_PRIVILEGED === "true";
    }
    static createDisabledInstance() {
        logger_1.log.debug(`Not creating new Reaper for session "${session_id_1.sessionId}"`);
        return Promise.resolve(new DisabledReaper());
    }
    static createRealInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            const containerPort = process.env["TESTCONTAINERS_RYUK_PORT"]
                ? { container: 8080, host: Number(process.env["TESTCONTAINERS_RYUK_PORT"]) }
                : 8080;
            const dockerClient = yield (0, docker_client_1.getDockerClient)();
            const remoteDockerUnixSocketPath = (0, remote_docker_unix_socket_path_1.getRemoteDockerUnixSocketPath)(dockerClient);
            logger_1.log.debug(`Creating new Reaper for session "${session_id_1.sessionId}" with socket path "${remoteDockerUnixSocketPath}"...`);
            const container = new generic_container_1.GenericContainer(images_1.REAPER_IMAGE)
                .withName(`testcontainers-ryuk-${session_id_1.sessionId}`)
                .withExposedPorts(containerPort)
                .withBindMounts([
                {
                    source: remoteDockerUnixSocketPath,
                    target: "/var/run/docker.sock",
                },
            ])
                .withWaitStrategy(wait_1.Wait.forLogMessage(/.+ Started!/));
            if (this.isPrivileged()) {
                container.withPrivilegedMode();
            }
            const startedContainer = yield container.start();
            const containerId = startedContainer.getId();
            const host = startedContainer.getHost();
            const port = startedContainer.getMappedPort(8080);
            const retryStrategy = new retry_strategy_1.IntervalRetryStrategy(1000);
            const retryResult = yield retryStrategy.retryUntil((attempt) => {
                return new Promise((resolve) => {
                    logger_1.log.debug(`Connecting to Reaper (attempt ${attempt + 1}) on "${host}:${port}"...`, { containerId });
                    const socket = new net_1.Socket();
                    socket
                        .unref()
                        .on("timeout", () => logger_1.log.error(`Reaper ${containerId} socket timed out`))
                        .on("error", (err) => logger_1.log.error(`Reaper ${containerId} socket error: ${err}`))
                        .on("close", (hadError) => {
                        if (hadError) {
                            logger_1.log.error(`Connection to Reaper closed with error`, { containerId });
                        }
                        else {
                            logger_1.log.warn(`Connection to Reaper closed`, { containerId });
                        }
                        resolve(undefined);
                    })
                        .connect((0, port_1.getContainerPort)(port), host, () => {
                        logger_1.log.debug(`Connected to Reaper`, { containerId });
                        socket.write(`label=${labels_1.LABEL_TESTCONTAINERS_SESSION_ID}=${session_id_1.sessionId}\r\n`);
                        const reaper = new RealReaper(startedContainer, socket);
                        resolve(reaper);
                    });
                });
            }, (result) => result !== undefined, () => {
                const message = `Failed to connect to Reaper`;
                logger_1.log.error(message, { containerId });
                return new Error(message);
            }, 4000);
            if (retryResult instanceof RealReaper) {
                return retryResult;
            }
            else {
                throw retryResult;
            }
        });
    }
}
exports.ReaperInstance = ReaperInstance;
