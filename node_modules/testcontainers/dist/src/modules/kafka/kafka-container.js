"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedKafkaContainer = exports.KafkaContainer = exports.KAFKA_IMAGE = void 0;
const generic_container_1 = require("../../generic-container/generic-container");
const uuid_1 = require("../../uuid");
const abstract_started_container_1 = require("../abstract-started-container");
const KAFKA_PORT = 9093;
const KAFKA_BROKER_PORT = 9092;
const DEFAULT_ZOOKEEPER_PORT = 2181;
exports.KAFKA_IMAGE = "confluentinc/cp-kafka:7.2.2";
class KafkaContainer extends generic_container_1.GenericContainer {
    constructor(image = exports.KAFKA_IMAGE) {
        super(image);
        this.uuid = new uuid_1.RandomUuid();
        this.isZooKeeperProvided = false;
        this.withExposedPorts(KAFKA_PORT).withStartupTimeout(180000).withEnvironment({
            KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: "BROKER:PLAINTEXT,PLAINTEXT:PLAINTEXT",
            KAFKA_INTER_BROKER_LISTENER_NAME: "BROKER",
            KAFKA_BROKER_ID: "1",
            KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: "1",
            KAFKA_OFFSETS_TOPIC_NUM_PARTITIONS: "1",
            KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: "1",
            KAFKA_LOG_FLUSH_INTERVAL_MESSAGES: "9223372036854775807",
            KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: "0",
            KAFKA_CONFLUENT_SUPPORT_METRICS_ENABLE: "false",
        });
    }
    withZooKeeper(host, port) {
        this.isZooKeeperProvided = true;
        this.zooKeeperHost = host;
        this.zooKeeperPort = port;
        return this;
    }
    withSaslSslListener(options) {
        this.saslSslConfig = options;
        return this;
    }
    beforeContainerStarted() {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.networkMode && this.networkAliases.length > 0 ? this.networkAliases[0] : "localhost";
            this.withEnvironment({ KAFKA_ADVERTISED_LISTENERS: `BROKER://${network}:${KAFKA_BROKER_PORT}` });
            if (this.saslSslConfig) {
                this.addPlaintextAndSecureListener(this.saslSslConfig);
            }
            else {
                this.addPlaintextListener();
            }
            let command = "#!/bin/bash\n";
            if (this.isZooKeeperProvided) {
                this.withEnvironment({ KAFKA_ZOOKEEPER_CONNECT: `${this.zooKeeperHost}:${this.zooKeeperPort}` });
            }
            else {
                this.zooKeeperHost = this.uuid.nextUuid();
                this.zooKeeperPort = DEFAULT_ZOOKEEPER_PORT;
                this.withExposedPorts(this.zooKeeperPort);
                this.withEnvironment({ KAFKA_ZOOKEEPER_CONNECT: `localhost:${this.zooKeeperPort}` });
                command += "echo 'clientPort=" + this.zooKeeperPort + "' > zookeeper.properties\n";
                command += "echo 'dataDir=/var/lib/zookeeper/data' >> zookeeper.properties\n";
                command += "echo 'dataLogDir=/var/lib/zookeeper/log' >> zookeeper.properties\n";
                command += "zookeeper-server-start zookeeper.properties &\n";
            }
            command += "echo '' > /etc/confluent/docker/ensure \n";
            command += "/etc/confluent/docker/run \n";
            this.withCommand(["sh", "-c", command]);
        });
    }
    start() {
        const _super = Object.create(null, {
            start: { get: () => super.start }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return new StartedKafkaContainer(yield _super.start.call(this));
        });
    }
    containerStarted(container, inspectResult) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateAdvertisedListeners(container, inspectResult);
            if (this.saslSslConfig) {
                yield this.createUser(container, this.saslSslConfig.sasl);
            }
        });
    }
    addPlaintextAndSecureListener({ port, sasl, keystore, truststore }) {
        this.withEnvironment({
            KAFKA_LISTENERS: `SECURE://0.0.0.0:${port},PLAINTEXT://0.0.0.0:${KAFKA_PORT},BROKER://0.0.0.0:${KAFKA_BROKER_PORT}`,
            KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: "BROKER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SECURE:SASL_SSL",
            KAFKA_SSL_PROTOCOL: "TLSv1.2",
            KAFKA_SSL_KEYSTORE_LOCATION: "/etc/kafka/secrets/server.keystore.pfx",
            KAFKA_SSL_KEYSTORE_PASSWORD: keystore.passphrase,
            KAFKA_SSL_KEYSTORE_TYPE: "PKCS12",
            KAFKA_SASL_ENABLED_MECHANISMS: sasl.mechanism,
            [`KAFKA_LISTENER_NAME_SECURE_${sasl.mechanism}_SASL_JAAS_CONFIG`]: "org.apache.kafka.common.security.scram.ScramLoginModule required;",
        })
            .withCopyContentToContainer([{ content: keystore.content, target: "/etc/kafka/secrets/server.keystore.pfx" }])
            .withExposedPorts(KAFKA_PORT, port);
        if (truststore) {
            this.withCopyContentToContainer([
                { content: truststore.content, target: "/etc/kafka/secrets/server.truststore.pfx" },
            ]).withEnvironment({
                KAFKA_SSL_TRUSTSTORE_LOCATION: "/etc/kafka/secrets/server.truststore.pfx",
                KAFKA_SSL_TRUSTSTORE_PASSWORD: truststore.passphrase,
                KAFKA_SSL_TRUSTSTORE_TYPE: "PKCS12",
            });
        }
    }
    addPlaintextListener() {
        this.withEnvironment({
            KAFKA_LISTENERS: `PLAINTEXT://0.0.0.0:${KAFKA_PORT},BROKER://0.0.0.0:${KAFKA_BROKER_PORT}`,
        }).withExposedPorts(KAFKA_PORT);
    }
    updateAdvertisedListeners(container, inspectResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const brokerAdvertisedListener = `BROKER://${inspectResult.hostname}:${KAFKA_BROKER_PORT}`;
            let bootstrapServers = `PLAINTEXT://${container.getHost()}:${container.getMappedPort(KAFKA_PORT)}`;
            if (this.saslSslConfig) {
                bootstrapServers = `${bootstrapServers},SECURE://${container.getHost()}:${container.getMappedPort(this.saslSslConfig.port)}`;
            }
            const { output, exitCode } = yield container.exec([
                "kafka-configs",
                "--alter",
                "--bootstrap-server",
                brokerAdvertisedListener,
                "--entity-type",
                "brokers",
                "--entity-name",
                this.opts.environment["KAFKA_BROKER_ID"],
                "--add-config",
                `advertised.listeners=[${bootstrapServers},${brokerAdvertisedListener}]`,
            ]);
            if (exitCode !== 0) {
                throw new Error(`Kafka container configuration failed with exit code ${exitCode}: ${output}`);
            }
        });
    }
    createUser(container, { user: { name, password }, mechanism }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { output, exitCode } = yield container.exec([
                "kafka-configs",
                "--alter",
                // At the time of writing kafka-configs displays a warning stating that the 'zookeeper' flag is deprecated in favor of 'bootstrap-server'.
                // Unfortunately, 'bootstrap-server' can only be used to set quotas and not to create a user.
                "--zookeeper",
                this.opts.environment["KAFKA_ZOOKEEPER_CONNECT"],
                "--entity-type",
                "users",
                "--entity-name",
                `${name}`,
                "--add-config",
                `${mechanism}=[password=${password}]`,
            ]);
            if (exitCode !== 0) {
                throw new Error(`Kafka container configuration failed with exit code ${exitCode}: ${output}`);
            }
        });
    }
}
exports.KafkaContainer = KafkaContainer;
class StartedKafkaContainer extends abstract_started_container_1.AbstractStartedContainer {
    constructor(startedTestContainer) {
        super(startedTestContainer);
    }
}
exports.StartedKafkaContainer = StartedKafkaContainer;
