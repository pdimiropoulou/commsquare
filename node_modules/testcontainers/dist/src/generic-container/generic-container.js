"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericContainer = void 0;
const archiver_1 = __importDefault(require("archiver"));
const async_lock_1 = __importDefault(require("async-lock"));
const bound_ports_1 = require("../bound-ports");
const logger_1 = require("../logger");
const pull_policy_1 = require("../pull-policy");
const reaper_1 = require("../reaper");
const docker_image_name_1 = require("../docker-image-name");
const port_forwarder_1 = require("../port-forwarder");
const pull_image_1 = require("../docker/functions/image/pull-image");
const create_container_1 = require("../docker/functions/container/create-container");
const connect_network_1 = require("../docker/functions/network/connect-network");
const docker_client_1 = require("../docker/client/docker-client");
const inspect_container_1 = require("../docker/functions/container/inspect-container");
const start_container_1 = require("../docker/functions/container/start-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const put_container_archive_1 = require("../docker/functions/container/put-container-archive");
const generic_container_builder_1 = require("./generic-container-builder");
const started_generic_container_1 = require("./started-generic-container");
const hash_1 = require("../hash");
const get_container_1 = require("../docker/functions/container/get-container");
const labels_1 = require("../labels");
const wait_for_container_1 = require("../wait-for-container");
const create_container_options_1 = require("./create-container-options");
const wait_1 = require("../wait-strategy/wait");
const reusableContainerCreationLock = new async_lock_1.default();
class GenericContainer {
    static fromDockerfile(context, dockerfileName = "Dockerfile") {
        return new generic_container_builder_1.GenericContainerBuilder(context, dockerfileName);
    }
    constructor(image) {
        this.image = image;
        this.waitStrategy = wait_1.Wait.forListeningPorts();
        this.networkAliases = [];
        this.pullPolicy = new pull_policy_1.DefaultPullPolicy();
        const imageName = docker_image_name_1.DockerImageName.fromString(image);
        this.opts = (0, create_container_options_1.initCreateContainerOptions)(imageName, imageName.isReaper());
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const { dockerode, info } = yield (0, docker_client_1.getDockerClient)();
            yield (0, pull_image_1.pullImage)(dockerode, info.dockerInfo.indexServerAddress, {
                imageName: this.opts.imageName,
                force: this.pullPolicy.shouldPull(),
            });
            if (!this.opts.reusable && !this.opts.imageName.isReaper()) {
                yield reaper_1.ReaperInstance.getInstance();
            }
            if (this.beforeContainerStarted) {
                yield this.beforeContainerStarted();
            }
            else if (this.preStart) {
                yield this.preStart();
            }
            if (!this.opts.imageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance();
                this.opts.extraHosts.push({ host: "host.testcontainers.internal", ipAddress: portForwarder.getIpAddress() });
            }
            if (this.networkAliases.length > 0) {
                this.opts.networkMode = undefined;
            }
            else {
                this.opts.networkMode = this.networkMode;
            }
            if (this.opts.reusable) {
                const containerHash = (0, hash_1.hash)(JSON.stringify(this.opts));
                this.opts.labels = Object.assign(Object.assign({}, this.opts.labels), { [labels_1.LABEL_TESTCONTAINERS_CONTAINER_HASH]: containerHash });
                logger_1.log.debug(`Container reuse has been enabled with hash "${containerHash}"`);
                // We might have several async processes try to create a reusable container
                // at once, to avoid possibly creating too many of these, use a lock
                // on the containerHash, this ensures that only single reusable instance is created
                return reusableContainerCreationLock.acquire(containerHash, () => __awaiter(this, void 0, void 0, function* () {
                    const container = yield (0, get_container_1.getContainerByHash)(containerHash);
                    if (container !== undefined) {
                        logger_1.log.debug(`Found container to reuse with hash "${containerHash}"`, { containerId: container.id });
                        return this.reuseContainer(container);
                    }
                    else {
                        logger_1.log.debug("No container found to reuse");
                        return this.startContainer(this.opts);
                    }
                }));
            }
            else {
                return this.startContainer(this.opts);
            }
        });
    }
    reuseContainer(container) {
        return __awaiter(this, void 0, void 0, function* () {
            const { host, hostIps } = yield (0, docker_client_1.getDockerClient)();
            const inspectResult = yield (0, inspect_container_1.inspectContainer)(container);
            const boundPorts = bound_ports_1.BoundPorts.fromInspectResult(hostIps, inspectResult).filter(this.opts.exposedPorts);
            if (this.startupTimeout !== undefined) {
                this.waitStrategy.withStartupTimeout(this.startupTimeout);
            }
            if (this.containerStarting) {
                yield this.containerStarting(inspectResult, true);
            }
            yield (0, wait_for_container_1.waitForContainer)(container, this.waitStrategy, boundPorts);
            const startedContainer = new started_generic_container_1.StartedGenericContainer(container, host, inspectResult, boundPorts, inspectResult.name, this.waitStrategy);
            if (this.containerStarted) {
                yield this.containerStarted(startedContainer, inspectResult, true);
            }
            else if (this.postStart) {
                yield this.postStart(startedContainer, inspectResult, boundPorts);
            }
            return startedContainer;
        });
    }
    startContainer(createContainerOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const container = yield (0, create_container_1.createContainer)(createContainerOptions);
            if (!this.opts.imageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance();
                const portForwarderNetworkId = portForwarder.getNetworkId();
                const excludedNetworks = [portForwarderNetworkId, "none", "host"];
                if (!this.networkMode || !excludedNetworks.includes(this.networkMode)) {
                    yield (0, connect_network_1.connectNetwork)({
                        containerId: container.id,
                        networkId: portForwarderNetworkId,
                        networkAliases: [],
                    });
                }
            }
            if (this.networkMode && this.networkAliases.length > 0) {
                yield (0, connect_network_1.connectNetwork)({
                    containerId: container.id,
                    networkId: this.networkMode,
                    networkAliases: this.networkAliases,
                });
            }
            if (this.tarToCopy) {
                this.tarToCopy.finalize();
                yield (0, put_container_archive_1.putContainerArchive)({ container, stream: this.tarToCopy, containerPath: "/" });
            }
            logger_1.log.info(`Starting container for image "${this.opts.imageName}"...`, { containerId: container.id });
            if (this.containerCreated) {
                yield this.containerCreated(container.id);
            }
            yield (0, start_container_1.startContainer)(container);
            logger_1.log.info(`Started container for image "${this.opts.imageName}"`, { containerId: container.id });
            const { host, hostIps } = yield (0, docker_client_1.getDockerClient)();
            const inspectResult = yield (0, inspect_container_1.inspectContainer)(container);
            const boundPorts = bound_ports_1.BoundPorts.fromInspectResult(hostIps, inspectResult).filter(this.opts.exposedPorts);
            if (this.startupTimeout !== undefined) {
                this.waitStrategy.withStartupTimeout(this.startupTimeout);
            }
            if (logger_1.containerLog.enabled() || this.logConsumer !== undefined) {
                const logStream = yield (0, container_logs_1.containerLogs)(container);
                if (this.logConsumer !== undefined) {
                    this.logConsumer(logStream);
                }
                if (logger_1.containerLog.enabled()) {
                    logStream
                        .on("data", (data) => logger_1.containerLog.trace(data.trim(), { containerId: container.id }))
                        .on("err", (data) => logger_1.containerLog.error(data.trim(), { containerId: container.id }));
                }
            }
            if (this.containerStarting) {
                yield this.containerStarting(inspectResult, false);
            }
            yield (0, wait_for_container_1.waitForContainer)(container, this.waitStrategy, boundPorts);
            const startedContainer = new started_generic_container_1.StartedGenericContainer(container, host, inspectResult, boundPorts, inspectResult.name, this.waitStrategy);
            if (this.containerStarted) {
                yield this.containerStarted(startedContainer, inspectResult, false);
            }
            else if (this.postStart) {
                yield this.postStart(startedContainer, inspectResult, boundPorts);
            }
            return startedContainer;
        });
    }
    get hasExposedPorts() {
        return this.opts.exposedPorts.length !== 0;
    }
    withCommand(command) {
        this.opts.command = command;
        return this;
    }
    withEntrypoint(entrypoint) {
        this.opts.entrypoint = entrypoint;
        return this;
    }
    withName(name) {
        this.opts.name = name;
        return this;
    }
    withLabels(labels) {
        this.opts.labels = Object.assign(Object.assign({}, this.opts.labels), labels);
        return this;
    }
    withEnvironment(environment) {
        this.opts.environment = Object.assign(Object.assign({}, this.opts.environment), environment);
        return this;
    }
    withTmpFs(tmpFs) {
        this.opts.tmpFs = Object.assign(Object.assign({}, this.opts.tmpFs), tmpFs);
        return this;
    }
    withUlimits(ulimits) {
        this.opts.ulimits = Object.assign(Object.assign({}, this.opts.ulimits), ulimits);
        return this;
    }
    withAddedCapabilities(...capabilities) {
        var _a;
        this.opts.addedCapabilities = [...((_a = this.opts.addedCapabilities) !== null && _a !== void 0 ? _a : []), ...capabilities];
        return this;
    }
    withDroppedCapabilities(...capabilities) {
        var _a;
        this.opts.droppedCapabilities = [...((_a = this.opts.droppedCapabilities) !== null && _a !== void 0 ? _a : []), ...capabilities];
        return this;
    }
    withNetwork(network) {
        this.networkMode = network.getName();
        return this;
    }
    withNetworkMode(networkMode) {
        this.networkMode = networkMode;
        return this;
    }
    withNetworkAliases(...networkAliases) {
        this.networkAliases = [...this.networkAliases, ...networkAliases];
        return this;
    }
    withExtraHosts(extraHosts) {
        this.opts.extraHosts = [...this.opts.extraHosts, ...extraHosts];
        return this;
    }
    withExposedPorts(...ports) {
        this.opts.exposedPorts = [...this.opts.exposedPorts, ...ports];
        return this;
    }
    withBindMounts(bindMounts) {
        this.opts.bindMounts = bindMounts.map((bindMount) => (Object.assign({ mode: "rw" }, bindMount)));
        return this;
    }
    withHealthCheck(healthCheck) {
        this.opts.healthCheck = healthCheck;
        return this;
    }
    withStartupTimeout(startupTimeoutMs) {
        this.startupTimeout = startupTimeoutMs;
        return this;
    }
    withWaitStrategy(waitStrategy) {
        this.waitStrategy = waitStrategy;
        return this;
    }
    withDefaultLogDriver() {
        this.opts.useDefaultLogDriver = true;
        return this;
    }
    withPrivilegedMode() {
        this.opts.privilegedMode = true;
        return this;
    }
    withUser(user) {
        this.opts.user = user;
        return this;
    }
    withReuse() {
        this.opts.reusable = true;
        return this;
    }
    withPullPolicy(pullPolicy) {
        this.pullPolicy = pullPolicy;
        return this;
    }
    withIpcMode(ipcMode) {
        this.opts.ipcMode = ipcMode;
        return this;
    }
    withCopyFilesToContainer(filesToCopy) {
        const tar = this.getTarToCopy();
        filesToCopy.forEach(({ source, target }) => tar.file(source, { name: target }));
        return this;
    }
    withCopyContentToContainer(contentsToCopy) {
        const tar = this.getTarToCopy();
        contentsToCopy.forEach(({ content, target }) => tar.append(content, { name: target }));
        return this;
    }
    getTarToCopy() {
        if (!this.tarToCopy) {
            this.tarToCopy = (0, archiver_1.default)("tar");
        }
        return this.tarToCopy;
    }
    withWorkingDir(workingDir) {
        this.opts.workingDir = workingDir;
        return this;
    }
    withResourcesQuota({ memory, cpu }) {
        // Memory and CPU units from here: https://docs.docker.com/engine/api/v1.42/#tag/Container/operation/ContainerCreate
        // see Memory, NanoCpus parameters
        const ram = memory !== undefined ? memory * Math.pow(1024, 3) : undefined;
        const cpuQuota = cpu !== undefined ? cpu * Math.pow(10, 9) : undefined;
        this.opts.resourcesQuota = { memory: ram, cpu: cpuQuota };
        return this;
    }
    withLogConsumer(logConsumer) {
        this.logConsumer = logConsumer;
        return this;
    }
}
exports.GenericContainer = GenericContainer;
