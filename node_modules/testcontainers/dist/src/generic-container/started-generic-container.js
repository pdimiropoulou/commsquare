"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedGenericContainer = void 0;
const inspect_container_1 = require("../docker/functions/container/inspect-container");
const bound_ports_1 = require("../bound-ports");
const logger_1 = require("../logger");
const remove_container_1 = require("../docker/functions/container/remove-container");
const exec_container_1 = require("../docker/functions/container/exec-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const stopped_generic_container_1 = require("./stopped-generic-container");
const stop_container_1 = require("../docker/functions/container/stop-container");
const restart_container_1 = require("../docker/functions/container/restart-container");
const wait_for_container_1 = require("../wait-for-container");
const docker_client_1 = require("../docker/client/docker-client");
const async_lock_1 = __importDefault(require("async-lock"));
class StartedGenericContainer {
    constructor(container, host, inspectResult, boundPorts, name, waitStrategy) {
        this.container = container;
        this.host = host;
        this.inspectResult = inspectResult;
        this.boundPorts = boundPorts;
        this.name = name;
        this.waitStrategy = waitStrategy;
        this.stopContainerLock = new async_lock_1.default();
    }
    stop(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.stopContainerLock.acquire("stop", () => __awaiter(this, void 0, void 0, function* () {
                if (this.stoppedContainer) {
                    return this.stoppedContainer;
                }
                this.stoppedContainer = yield this.stopContainer(options);
                return this.stoppedContainer;
            }));
        });
    }
    restart(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedOptions = Object.assign({ timeout: 0 }, options);
            logger_1.log.info(`Restarting container...`, { containerId: this.container.id });
            yield (0, restart_container_1.restartContainer)(this.container, resolvedOptions);
            const { hostIps } = yield (0, docker_client_1.getDockerClient)();
            this.inspectResult = yield (0, inspect_container_1.inspectContainer)(this.container);
            const startTime = this.inspectResult.state.startedAt;
            if (logger_1.containerLog.enabled()) {
                (yield (0, container_logs_1.containerLogs)(this.container, { since: startTime }))
                    .on("data", (data) => logger_1.containerLog.trace(data.trim(), { containerId: this.container.id }))
                    .on("err", (data) => logger_1.containerLog.error(data.trim(), { containerId: this.container.id }));
            }
            this.boundPorts = bound_ports_1.BoundPorts.fromInspectResult(hostIps, this.inspectResult).filter(Array.from(this.boundPorts.iterator()).map((port) => port[0]));
            yield (0, wait_for_container_1.waitForContainer)(this.container, this.waitStrategy, this.boundPorts, startTime);
            logger_1.log.info(`Restarted container`, { containerId: this.container.id });
        });
    }
    stopContainer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Stopping container...`, { containerId: this.container.id });
            if (this.containerIsStopping) {
                yield this.containerIsStopping();
            }
            const resolvedOptions = Object.assign({ timeout: 0, removeVolumes: true }, options);
            yield (0, stop_container_1.stopContainer)(this.container, { timeout: resolvedOptions.timeout });
            yield (0, remove_container_1.removeContainer)(this.container, { removeVolumes: resolvedOptions.removeVolumes });
            logger_1.log.info(`Stopped container`, { containerId: this.container.id });
            if (this.containerIsStopped) {
                yield this.containerIsStopped();
            }
            return new stopped_generic_container_1.StoppedGenericContainer();
        });
    }
    getHost() {
        return this.host;
    }
    getFirstMappedPort() {
        return this.boundPorts.getFirstBinding();
    }
    getMappedPort(port) {
        return this.boundPorts.getBinding(port);
    }
    getId() {
        return this.container.id;
    }
    getName() {
        return this.name;
    }
    getLabels() {
        return this.inspectResult.labels;
    }
    getNetworkNames() {
        return Object.keys(this.inspectResult.networkSettings);
    }
    getNetworkId(networkName) {
        return this.inspectResult.networkSettings[networkName].networkId;
    }
    getIpAddress(networkName) {
        return this.inspectResult.networkSettings[networkName].ipAddress;
    }
    exec(command) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dockerode, containerRuntime } = yield (0, docker_client_1.getDockerClient)();
            logger_1.log.debug(`Executing command "${command.join(" ")}"...`, { containerId: this.container.id });
            const output = yield (0, exec_container_1.execContainer)(dockerode, containerRuntime, this.container, command);
            logger_1.log.debug(`Executed command "${command.join(" ")}"...`, { containerId: this.container.id });
            return output;
        });
    }
    logs() {
        return (0, container_logs_1.containerLogs)(this.container);
    }
}
exports.StartedGenericContainer = StartedGenericContainer;
