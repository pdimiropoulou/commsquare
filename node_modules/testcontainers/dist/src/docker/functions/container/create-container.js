"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createContainer = void 0;
const logger_1 = require("../../../logger");
const docker_client_1 = require("../../client/docker-client");
const port_1 = require("../../../port");
const create_labels_1 = require("../create-labels");
const createContainer = (options) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        logger_1.log.info(`Creating container for image "${options.imageName}"...`);
        const { dockerode } = yield (0, docker_client_1.getDockerClient)();
        const container = yield dockerode.createContainer({
            name: options.name,
            User: options.user,
            Image: options.imageName.toString(),
            Env: getEnvironment(options.environment),
            ExposedPorts: getExposedPorts(options.exposedPorts),
            Cmd: options.command,
            Entrypoint: options.entrypoint,
            Labels: (0, create_labels_1.createLabels)(options.reusable, options.imageName, options.labels),
            Healthcheck: getHealthCheck(options.healthCheck),
            WorkingDir: options.workingDir,
            HostConfig: {
                IpcMode: options.ipcMode,
                ExtraHosts: getExtraHosts(options.extraHosts),
                AutoRemove: options.autoRemove,
                NetworkMode: options.networkMode,
                PortBindings: getPortBindings(options.exposedPorts),
                Binds: getBindMounts(options.bindMounts),
                Tmpfs: options.tmpFs,
                LogConfig: getLogConfig(options.useDefaultLogDriver),
                Privileged: options.privilegedMode,
                Ulimits: getUlimits(options.ulimits),
                CapAdd: options.addedCapabilities,
                CapDrop: options.droppedCapabilities,
                Memory: (_a = options.resourcesQuota) === null || _a === void 0 ? void 0 : _a.memory,
                NanoCpus: (_b = options.resourcesQuota) === null || _b === void 0 ? void 0 : _b.cpu,
            },
        });
        logger_1.log.info(`Created container for image "${options.imageName}"`, { containerId: container.id });
        return container;
    }
    catch (err) {
        logger_1.log.error(`Failed to create container for image "${options.imageName}": ${err}`);
        throw err;
    }
});
exports.createContainer = createContainer;
const getEnvironment = (environment) => Object.entries(environment).reduce((dockerodeEnvironment, [key, value]) => [...dockerodeEnvironment, `${key}=${value}`], []);
const getExposedPorts = (exposedPorts) => {
    const dockerodeExposedPorts = {};
    for (const exposedPort of exposedPorts) {
        dockerodeExposedPorts[(0, port_1.getContainerPort)(exposedPort).toString()] = {};
    }
    return dockerodeExposedPorts;
};
const getExtraHosts = (extraHosts) => {
    return extraHosts.map((extraHost) => `${extraHost.host}:${extraHost.ipAddress}`);
};
const getPortBindings = (exposedPorts) => {
    const dockerodePortBindings = {};
    for (const exposedPort of exposedPorts) {
        if ((0, port_1.hasHostBinding)(exposedPort)) {
            dockerodePortBindings[exposedPort.container] = [{ HostPort: exposedPort.host.toString() }];
        }
        else {
            dockerodePortBindings[exposedPort] = [{ HostPort: "0" }];
        }
    }
    return dockerodePortBindings;
};
const getBindMounts = (bindMounts) => {
    return bindMounts.map(({ source, target, mode }) => `${source}:${target}:${mode}`);
};
const getHealthCheck = (healthCheck) => {
    if (healthCheck === undefined) {
        return undefined;
    }
    return {
        Test: healthCheck.test,
        Interval: healthCheck.interval ? toNanos(healthCheck.interval) : 0,
        Timeout: healthCheck.timeout ? toNanos(healthCheck.timeout) : 0,
        Retries: healthCheck.retries || 0,
        StartPeriod: healthCheck.startPeriod ? toNanos(healthCheck.startPeriod) : 0,
    };
};
const toNanos = (duration) => duration * 1e6;
const getLogConfig = (useDefaultLogDriver) => {
    if (!useDefaultLogDriver) {
        return undefined;
    }
    return {
        Type: "json-file",
        Config: {},
    };
};
const getUlimits = (ulimits) => {
    if (!ulimits) {
        return undefined;
    }
    return Object.entries(ulimits).map(([key, value]) => ({
        Name: key,
        Hard: value.hard,
        Soft: value.soft,
    }));
};
