"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDockerClient = void 0;
const logger_1 = require("../../logger");
const lookup_host_ips_1 = require("../lookup-host-ips");
const system_info_1 = require("../../system-info");
const rootless_unix_socket_strategy_1 = require("./strategy/rootless-unix-socket-strategy");
const stream_utils_1 = require("../../stream-utils");
const stream_1 = require("stream");
const resolve_host_1 = require("../resolve-host");
const configuration_strategy_1 = require("./strategy/configuration-strategy");
const unix_socket_strategy_1 = require("./strategy/unix-socket-strategy");
const npipe_socket_strategy_1 = require("./strategy/npipe-socket-strategy");
const testcontainers_host_strategy_1 = require("./strategy/testcontainers-host-strategy");
let dockerClient;
function getDockerClient() {
    return __awaiter(this, void 0, void 0, function* () {
        if (dockerClient) {
            return dockerClient;
        }
        const strategies = [
            new testcontainers_host_strategy_1.TestcontainersHostStrategy(),
            new configuration_strategy_1.ConfigurationStrategy(),
            new unix_socket_strategy_1.UnixSocketStrategy(),
            new rootless_unix_socket_strategy_1.RootlessUnixSocketStrategy(),
            new npipe_socket_strategy_1.NpipeSocketStrategy(),
        ];
        for (const strategy of strategies) {
            if (strategy.init) {
                yield strategy.init();
            }
            if (strategy.isApplicable()) {
                logger_1.log.debug(`Found Docker client strategy "${strategy.getName()}"`);
                const { uri, dockerode, composeEnvironment, allowUserOverrides } = yield strategy.getDockerClient();
                logger_1.log.debug(`Testing Docker client strategy "${uri}"...`);
                if (yield isDockerDaemonReachable(dockerode)) {
                    const info = yield (0, system_info_1.getSystemInfo)(dockerode);
                    const containerRuntime = uri.includes("podman.sock") ? "podman" : "docker";
                    const host = yield (0, resolve_host_1.resolveHost)(dockerode, containerRuntime, info.dockerInfo.indexServerAddress, uri, allowUserOverrides);
                    const hostIps = yield (0, lookup_host_ips_1.lookupHostIps)(host);
                    dockerClient = {
                        uri,
                        containerRuntime,
                        host,
                        hostIps,
                        dockerode,
                        info,
                        composeEnvironment,
                        allowUserOverrides,
                    };
                    logDockerClient(strategy.getName(), dockerClient);
                    return dockerClient;
                }
                else {
                    logger_1.log.warn(`Docker client strategy "${strategy.getName()}" is not working`);
                }
            }
        }
        throw new Error("No Docker client strategy found");
    });
}
exports.getDockerClient = getDockerClient;
function isDockerDaemonReachable(dockerode) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const response = yield dockerode.ping();
            return (yield (0, stream_utils_1.streamToString)(stream_1.Readable.from(response))) === "OK";
        }
        catch (err) {
            logger_1.log.warn(`Docker daemon is not reachable: ${err}`);
            return false;
        }
    });
}
function logDockerClient(strategyName, { host, hostIps }) {
    if (!logger_1.log.enabled()) {
        return;
    }
    const formattedHostIps = hostIps.map((hostIp) => hostIp.address).join(", ");
    logger_1.log.info(`Using Docker client strategy "${strategyName}", Docker host "${host}" (${formattedHostIps})`);
}
