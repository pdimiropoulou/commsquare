"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDockerClientConfig = void 0;
const path_1 = __importDefault(require("path"));
const logger_1 = require("../../logger");
const os_1 = require("os");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const properties_reader_1 = __importDefault(require("properties-reader"));
const getDockerClientConfig = (env = process.env) => __awaiter(void 0, void 0, void 0, function* () {
    const dockerClientConfig = Object.assign(Object.assign({}, (yield loadFromFile())), loadFromEnv(env));
    logDockerClientConfig(dockerClientConfig);
    return dockerClientConfig;
});
exports.getDockerClientConfig = getDockerClientConfig;
function loadFromFile() {
    return __awaiter(this, void 0, void 0, function* () {
        const file = path_1.default.resolve((0, os_1.homedir)(), ".testcontainers.properties");
        const dockerClientConfig = {};
        if ((0, fs_1.existsSync)(file)) {
            logger_1.log.debug(`Loading ".testcontainers.properties" file...`);
            const string = yield (0, promises_1.readFile)(file, { encoding: "utf-8" });
            const properties = (0, properties_reader_1.default)("").read(string);
            const tcHost = properties.get("tc.host");
            if (tcHost !== null) {
                dockerClientConfig.tcHost = tcHost;
            }
            const dockerHost = properties.get("docker.host");
            if (dockerHost !== null) {
                dockerClientConfig.dockerHost = dockerHost;
            }
            const dockerTlsVerify = properties.get("docker.tls.verify");
            if (dockerTlsVerify !== null) {
                dockerClientConfig.dockerTlsVerify = `${dockerTlsVerify}`;
            }
            const dockerCertPath = properties.get("docker.cert.path");
            if (dockerCertPath !== null) {
                dockerClientConfig.dockerCertPath = dockerCertPath;
            }
        }
        return dockerClientConfig;
    });
}
function loadFromEnv(env) {
    const dockerClientConfig = {};
    if (env["DOCKER_HOST"] !== undefined) {
        dockerClientConfig.dockerHost = env["DOCKER_HOST"];
    }
    if (env["DOCKER_TLS_VERIFY"] !== undefined) {
        dockerClientConfig.dockerTlsVerify = env["DOCKER_TLS_VERIFY"];
    }
    if (env["DOCKER_CERT_PATH"] !== undefined) {
        dockerClientConfig.dockerCertPath = env["DOCKER_CERT_PATH"];
    }
    return dockerClientConfig;
}
function logDockerClientConfig(config) {
    if (!logger_1.log.enabled()) {
        return;
    }
    const configurations = Object.entries(config)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => `${key}: "${value}"`);
    if (configurations.length > 0) {
        logger_1.log.debug(`Loaded Docker client configuration, ${configurations.join(", ")}`);
    }
}
